---
title: 'Agent 中间件'
titleJp: ''
date: '2025-11-06'
excerpt: ''
tags: ["Translate"]
---
# Agent 中间件 (Agent Middleware)

LangChain 拥有 agent 抽象已经快三年了。现在可能有 100 多个 agent 框架都具有相同的核心抽象。它们都遭受着与 LangChain 原始 agent 相同的缺点：**它们没有在需要时给予开发者足够的对上下文工程（context engineering）的控制**，导致开发者在处理任何非琐碎的用例时，最终都会“毕业”并抛弃这个抽象。在 LangChain 1.0 中，我们引入了一种新的 agent 抽象（`Middleware`），我们认为它解决了这个问题。

核心的 agent 组件非常简单：

* 一个模型（model）
* 一个提示（prompt）
* 一个工具列表（list of tools）

核心的 agent 算法也同样简单。用户首先用一些输入消息调用 agent，然后 agent 在一个循环中运行，调用工具，将 AI 和工具消息添加到其状态中，直到它决定不再调用任何工具并最终完成。

我们在 2022 年 11 月的 LangChain 中就有这个版本的 agent，在过去的3年里，涌现出了 100 多个具有相似抽象的框架。

与此同时，虽然让一个基本的 agent 抽象跑起来很简单，但要让这个抽象变得足够灵活，以便将其投入生产环境，却非常困难。

在这篇博文中，我们将涵盖：

* 为什么很难让这个抽象变得足够可靠以便投入生产
* 在过去一年左右的时间里，我们为了使其更可靠所做的努力
* 我们在 LangChain 1.0 中引入的一个新的 `Middleware` 抽象，我们认为这使它成为最灵活、最可组合的 agent 抽象

---

### 为什么很难将这个抽象投入生产

那么，为什么用这些框架构建可靠的 agent 仍然如此困难？为什么许多人在达到一定复杂程度时，会放弃框架，转而使用自定义代码？

**答案是上下文工程（Context Engineering）。**

进入模型的上下文（context）决定了模型输出什么。为了使模型（并因此使 agent）更可靠，你希望完全控制进入模型的内容。虽然这个简单的 agent 状态和简单的 agent 循环非常适合入门，但当你推动 agent 性能的极限时，你很可能会想要修改其中的一部分。

随着复杂性的增加，你可能希望在很多方面有更多的控制权：

* 你可能想调整 agent 的“状态（state）”，使其包含的不仅仅是消息
* 你可能想更精确地控制*到底*有哪些内容进入了模型
* 你可能想更精确地控制所运行的步骤顺序

---

### 我们为使其更可靠所做的努力

在过去的两年里，我们努力使我们的 agent 抽象更好地支持上下文工程。我们做的一些事情（大致按时间顺序）：

* 允许用户指定运行时配置，以传入诸如连接字符串和只读用户信息之类的内容
* 允许用户指定任意的状态模式（state schemas），用户或 agent 都可以更新这些状态
* 允许用户指定一个*函数*来返回提示，而不是一个固定的字符串，从而实现动态提示
* 允许用户指定一个*函数*来返回消息列表，从而完全控制发送给模型的整个消息列表
* 允许用户指定一个“模型前钩子（pre model hook）”，在模型被调用*之前*运行一个步骤，该步骤可以更新状态或跳转到不同的节点。这允许了诸如长对话摘要之类的功能。
* 允许用户指定一个“模型后钩子（post model hook）”，在模型被调用*之后*运行一个步骤，该步骤可以更新状态或跳转到不同的节点。这允许了诸如“人工审批（human-in-the-loop）”和“护栏（guardrails）”之类的功能。
* 允许用户指定一个函数来返回在每次调用时要使用的模型，从而实现动态模型切换和动态工具调用。

这允许了对上下文工程进行高层次的定制和控制。

**但这也导致了 agent 有大量的参数。** 此外，这些参数之间经常相互依赖，这使得协调变得困难。而且很难将这些参数的多个版本组合在一起，或者提供“开箱即用”的变体来尝试。

---

### 我们在 LangChain 1.0 中正在做的事

对于 LangChain 1.0，我们正倾向于通过引入**中间件（`Middleware`）**的概念来修改这个核心 agent 循环。

核心 agent 循环仍将由一个模型节点和一个工具节点组成。但是 `Middleware` 现在可以指定：

* **`before_model`**：将在模型调用*之前*运行，可以更新状态或跳转到其他节点。
* **`after_model`**：将在模型调用*之后*运行，可以更新状态或跳转到其他节点。
* **`modify_model_request`**：将在模型调用*之前*运行，允许用户（仅针对该模型请求）修改工具、提示、消息列表、模型、模型设置、输出格式和工具选择。

你可以向一个 agent 提供**多个**中间件。它们将像 Web 服务器中的中间件一样运行：在进入模型调用的路上**顺序执行**（`before_model`, `modify_model_request`），在返回的路上**逆序执行**（`after_model`）。

中间件还可以指定自定义的状态模式（state schemas）和工具。

我们将提供“开箱即用”的中间件，供开发者上手使用。我们还将维护一个社区中间件列表，以便轻松访问。一段时间以来，开发者一直要求提供可插入 LangGraph agent 的节点集合。这（中间件）正是那个东西。

中间件还将帮助我们统一我们不同的 agent 抽象。我们目前有针对 supervisor（主管）、swarm（集群）、bigtool（大型工具）、deepagents（深度智能体）、reflection（反思）等的独立 LangGraph agent。我们已经验证，我们将能够使用中间件复制这些架构。

---

### 在 LangChain 1.0 alpha 中尝试它

你可以在最新的 LangChain 1.0 alpha 版本（Python 和 JavaScript）中试用中间件。这是 LangChain 1.0 中最大的新部分，所以我们**非常希望**得到关于中间件的反馈。

作为此 alpha 版本的一部分，我们还发布了三种不同的中间件实现（我们已经在内部的 agent 中使用了所有这些实现）：

1.  **人工审批（Human-in-the-loop）**：使用 `Middleware.after_model` 来提供一种“开箱即用”的方式，为工具调用添加中断，以获取“人工审批”的反馈。
2.  **摘要（Summarization）**：使用 `Middleware.before_model`，在消息累积超过一定阈值时对消息进行摘要。
3.  **Anthropic 提示词缓存（Anthropic Prompt Caching）**：使用 `Middleware.modify_model_request` 向消息添加特殊的提示词缓存标签。

**在 Python 中尝试:**
`pip install --pre -U langchain`

**在 JavaScript 中尝试:**
`npm install langchain@next`